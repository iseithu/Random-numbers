# -*- coding: utf-8 -*-
"""Problems_random.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1R67GPzlPoiRk1EXE4vZjgtedVy4DMQJ6

### Exercise   #1: Game

Somebody suggests the following game. You pay 1 Euro and are allowed to throw four dice. If the sum on the dice is less than 9, you get paid $r$ Euros back, otherwise, you lose 1 Euro of investment (say $r$ = 10).
Will you then in the long run win or lose money by playing this game? Make a program to simulate the game.


### Exercise #2: Compute $\pi$ by a Monte Carlo method
a) Compute $\pi$ by computing the area of a circle. Choose $G$ as the circle with its centre at the origin and with unit radius, and choose $B$ as the rectangle $[-1,1] \times [-1,1]$. A point $(x,y)$ lies within $G$ if $x^2+y^2 < 1$.
Compare your estimated value with ${\tt math.pi}$


b) This time you should choose $G$ as a circle with a centre at (2,1) and a radius 4. Select an appropriate rectangle $B$.
A point $(x,y)$ lies within a circle at center $(x_c,y_c)$ if $(x-x_c)^2 + (y-y_c)^2 < R^2$


### Exercise #3: Comute $\pi$ by a random sum

a) Let $x_0, x_1, ...,x_N$ be the $N + 1$ uniformly distributed random numbers between 0 and 1. Explain why the random sum $S_N = (N +1 ) ^{-1} \sum_{i=0}^N 2(1-x_i^2)^{-1/2}$ is an approximation to $\pi$.

<p style="font-family: 'Arial';font-size: 18px;  color: red;">Hint: Interpret the sum as Monte Carlo Integration and compute the corresponding integral by hand / scipy}</p>

b) Compute $S_0, S_1, ..., S_N$ using just one set of $N+1$ random numbers. Plot this sequence versus $N$. Also plot the horizontal line corresponding to $\pi$. Choose $N$ large, e.g., $N=10^6$.


### Exercise #4: Random walk with drift

Modify the program we have sen walk1D.py such that the probability of going to the right is $r$ and the probability of going to the left is $1-r$ (draw numbers in [0,1) rather than integers in \{1,2\}). Compute the aerage position of $n_p$ particles after 100 steps.

Mathematically one can show that the aerage position approaches $rn_s - (1-r)n_s$ as $n_p \rightarrow \infty$ ($n_s$ is the number of
walks). Write out this exact result together with the computed mean position with a finite number of particles.
"""

import numpy as np
r=10
total_money=0
no_throws=100
for i in range(no_throws):
  total_money+=-1
  throws=np.random.randint(1,7,4)
  result=np.sum(throws)

  if result<9:
    payment=r
    total_money+=payment
print(total_money)

import matplotlib.pyplot as plt
import numpy as np

def MCint_dart_vec(f,a,b,n,c,d):

  x=np.random.uniform(a,b,n)
  y=np.random.uniform(c,d,n)
  inside=np.sum((y<f(x)) & (y>-f(x)))
  area=(inside/n)*(d-c)*(b-a)
  plt.scatter(x, y, c=["blue" if (y[i]<f(x[i])) & (y[i]>-f(x[i])) else "red" for i in range(n)], s=1)
  plt.plot(np.linspace(a, b,100), f(np.linspace(a,b,100)),color="green")
  plt.plot(np.linspace(a,b,100), -f(np.linspace(a,b,100)),color="green")
  plt.xlabel("x")
  plt.ylabel("y")
  plt.gca().set_aspect('equal', adjustable='box')

  plt.grid()
  plt.xlim(a, b)
  plt.ylim(c, d)


  plt.title("Monte Carlo Integration Visualization")
  plt.show()
  return area

f= lambda x: np.sqrt(1-x**2)
result=np.random.seed(0)
result = MCint_dart_vec(f,-1,1,10000,-1,1)

print(result)
plt.savefig("output_graph.png", dpi=300, bbox_inches="tight")

from google.colab import files
files.download("output_graph.png")

from IPython.core.interactiveshell import dis
import matplotlib.pyplot as plt
import numpy as np
def MCint_dart_vec(R,cx,cy,n):
  a=cx-R
  b=cx+R
  c=cy-R
  d=cy+R

  x=np.random.uniform(a,b,n)
  y=np.random.uniform(c,d,n)
  distance=(x-cx)**2+(y-cy)**2
  x_inside=x[np.where(distance<R**2)]
  inside=len(x_inside)
  mask = distance < R**2

  area=(inside/n)*(d-c)*(b-a)
  colors = np.where(mask, "blue", "red")

  plt.scatter(x, y, c=colors, s=1)

  theta = np.linspace(0, 2*np.pi, 300)
  plt.plot(cx + R*np.cos(theta), cy + R*np.sin(theta), "green")
  plt.gca().set_aspect('equal', adjustable='box')
  plt.xlabel("x")
  plt.ylabel("y")
  plt.axis("equal")
  plt.grid()
  plt.xlim(a, b)
  plt.ylim(c, d)

  plt.title("Monte Carlo Integration Visualization")
  plt.show()
  return area

f= lambda x: np.sqrt(1-x**2)
result = MCint_dart_vec(4,2,1,1000)
print(result/16)

import numpy as np
import matplotlib.pyplot as plt

N = 1000000
x = np.random.rand(N+1)

S = np.cumsum(2 / np.sqrt(1 - x**2)) / np.arange(1, N+2)

plt.plot(S, label="Monte Carlo π")
plt.axhline(np.pi, color='red', label="π")
plt.xlabel("N")
plt.ylabel("Value")
plt.legend()
plt.show()

import numpy as np

r = 0.6
n_s = 100
n_p = 100000

steps = np.random.choice([1,-1], size=(n_p,n_s), p=[r,1-r])
positions = np.sum(steps, axis=1)

print("Simulated mean:", np.mean(positions))
print("Exact mean:", (2*r-1)*n_s)